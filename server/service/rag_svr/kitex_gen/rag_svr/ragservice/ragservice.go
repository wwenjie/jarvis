// Code generated by Kitex v0.13.1. DO NOT EDIT.

package ragservice

import (
	"context"
	"errors"
	"fmt"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "github.com/cloudwego/prutal"
	rag_svr "server/service/rag_svr/kitex_gen/rag_svr"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"Test": kitex.NewMethodInfo(
		testHandler,
		newTestArgs,
		newTestResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"Test2": kitex.NewMethodInfo(
		test2Handler,
		newTest2Args,
		newTest2Result,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CreateUser": kitex.NewMethodInfo(
		createUserHandler,
		newCreateUserArgs,
		newCreateUserResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CreateSession": kitex.NewMethodInfo(
		createSessionHandler,
		newCreateSessionArgs,
		newCreateSessionResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"EndSession": kitex.NewMethodInfo(
		endSessionHandler,
		newEndSessionArgs,
		newEndSessionResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"SendMessage": kitex.NewMethodInfo(
		sendMessageHandler,
		newSendMessageArgs,
		newSendMessageResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"SendMessageStream": kitex.NewMethodInfo(
		sendMessageStreamHandler,
		newSendMessageStreamArgs,
		newSendMessageStreamResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingServer),
	),
	"AddDocument": kitex.NewMethodInfo(
		addDocumentHandler,
		newAddDocumentArgs,
		newAddDocumentResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"SearchDocument": kitex.NewMethodInfo(
		searchDocumentHandler,
		newSearchDocumentArgs,
		newSearchDocumentResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetSessionList": kitex.NewMethodInfo(
		getSessionListHandler,
		newGetSessionListArgs,
		newGetSessionListResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CleanInactiveSessions": kitex.NewMethodInfo(
		cleanInactiveSessionsHandler,
		newCleanInactiveSessionsArgs,
		newCleanInactiveSessionsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	ragServiceServiceInfo                = NewServiceInfo()
	ragServiceServiceInfoForClient       = NewServiceInfoForClient()
	ragServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return ragServiceServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return ragServiceServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return ragServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(true, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "RagService"
	handlerType := (*rag_svr.RagService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "rag_svr",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.13.1",
		Extra:           extra,
	}
	return svcInfo
}

func testHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.TestReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).Test(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *TestArgs:
		success, err := handler.(rag_svr.RagService).Test(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*TestResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newTestArgs() interface{} {
	return &TestArgs{}
}

func newTestResult() interface{} {
	return &TestResult{}
}

type TestArgs struct {
	Req *rag_svr.TestReq
}

func (p *TestArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *TestArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.TestReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var TestArgs_Req_DEFAULT *rag_svr.TestReq

func (p *TestArgs) GetReq() *rag_svr.TestReq {
	if !p.IsSetReq() {
		return TestArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *TestArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *TestArgs) GetFirstArgument() interface{} {
	return p.Req
}

type TestResult struct {
	Success *rag_svr.TestRsp
}

var TestResult_Success_DEFAULT *rag_svr.TestRsp

func (p *TestResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *TestResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.TestRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *TestResult) GetSuccess() *rag_svr.TestRsp {
	if !p.IsSetSuccess() {
		return TestResult_Success_DEFAULT
	}
	return p.Success
}

func (p *TestResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.TestRsp)
}

func (p *TestResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestResult) GetResult() interface{} {
	return p.Success
}

func test2Handler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.Test2Req)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).Test2(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *Test2Args:
		success, err := handler.(rag_svr.RagService).Test2(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*Test2Result)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newTest2Args() interface{} {
	return &Test2Args{}
}

func newTest2Result() interface{} {
	return &Test2Result{}
}

type Test2Args struct {
	Req *rag_svr.Test2Req
}

func (p *Test2Args) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *Test2Args) Unmarshal(in []byte) error {
	msg := new(rag_svr.Test2Req)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var Test2Args_Req_DEFAULT *rag_svr.Test2Req

func (p *Test2Args) GetReq() *rag_svr.Test2Req {
	if !p.IsSetReq() {
		return Test2Args_Req_DEFAULT
	}
	return p.Req
}

func (p *Test2Args) IsSetReq() bool {
	return p.Req != nil
}

func (p *Test2Args) GetFirstArgument() interface{} {
	return p.Req
}

type Test2Result struct {
	Success *rag_svr.Test2Rsp
}

var Test2Result_Success_DEFAULT *rag_svr.Test2Rsp

func (p *Test2Result) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *Test2Result) Unmarshal(in []byte) error {
	msg := new(rag_svr.Test2Rsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *Test2Result) GetSuccess() *rag_svr.Test2Rsp {
	if !p.IsSetSuccess() {
		return Test2Result_Success_DEFAULT
	}
	return p.Success
}

func (p *Test2Result) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.Test2Rsp)
}

func (p *Test2Result) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *Test2Result) GetResult() interface{} {
	return p.Success
}

func createUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.CreateUserReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).CreateUser(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CreateUserArgs:
		success, err := handler.(rag_svr.RagService).CreateUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateUserResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCreateUserArgs() interface{} {
	return &CreateUserArgs{}
}

func newCreateUserResult() interface{} {
	return &CreateUserResult{}
}

type CreateUserArgs struct {
	Req *rag_svr.CreateUserReq
}

func (p *CreateUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateUserArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.CreateUserReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateUserArgs_Req_DEFAULT *rag_svr.CreateUserReq

func (p *CreateUserArgs) GetReq() *rag_svr.CreateUserReq {
	if !p.IsSetReq() {
		return CreateUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateUserResult struct {
	Success *rag_svr.CreateUserRsp
}

var CreateUserResult_Success_DEFAULT *rag_svr.CreateUserRsp

func (p *CreateUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateUserResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.CreateUserRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateUserResult) GetSuccess() *rag_svr.CreateUserRsp {
	if !p.IsSetSuccess() {
		return CreateUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.CreateUserRsp)
}

func (p *CreateUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateUserResult) GetResult() interface{} {
	return p.Success
}

func createSessionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.CreateSessionReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).CreateSession(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CreateSessionArgs:
		success, err := handler.(rag_svr.RagService).CreateSession(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateSessionResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCreateSessionArgs() interface{} {
	return &CreateSessionArgs{}
}

func newCreateSessionResult() interface{} {
	return &CreateSessionResult{}
}

type CreateSessionArgs struct {
	Req *rag_svr.CreateSessionReq
}

func (p *CreateSessionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateSessionArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.CreateSessionReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateSessionArgs_Req_DEFAULT *rag_svr.CreateSessionReq

func (p *CreateSessionArgs) GetReq() *rag_svr.CreateSessionReq {
	if !p.IsSetReq() {
		return CreateSessionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateSessionArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateSessionArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateSessionResult struct {
	Success *rag_svr.CreateSessionRsp
}

var CreateSessionResult_Success_DEFAULT *rag_svr.CreateSessionRsp

func (p *CreateSessionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateSessionResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.CreateSessionRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateSessionResult) GetSuccess() *rag_svr.CreateSessionRsp {
	if !p.IsSetSuccess() {
		return CreateSessionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateSessionResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.CreateSessionRsp)
}

func (p *CreateSessionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateSessionResult) GetResult() interface{} {
	return p.Success
}

func endSessionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.EndSessionReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).EndSession(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *EndSessionArgs:
		success, err := handler.(rag_svr.RagService).EndSession(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*EndSessionResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newEndSessionArgs() interface{} {
	return &EndSessionArgs{}
}

func newEndSessionResult() interface{} {
	return &EndSessionResult{}
}

type EndSessionArgs struct {
	Req *rag_svr.EndSessionReq
}

func (p *EndSessionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *EndSessionArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.EndSessionReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var EndSessionArgs_Req_DEFAULT *rag_svr.EndSessionReq

func (p *EndSessionArgs) GetReq() *rag_svr.EndSessionReq {
	if !p.IsSetReq() {
		return EndSessionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *EndSessionArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *EndSessionArgs) GetFirstArgument() interface{} {
	return p.Req
}

type EndSessionResult struct {
	Success *rag_svr.EndSessionRsp
}

var EndSessionResult_Success_DEFAULT *rag_svr.EndSessionRsp

func (p *EndSessionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *EndSessionResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.EndSessionRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *EndSessionResult) GetSuccess() *rag_svr.EndSessionRsp {
	if !p.IsSetSuccess() {
		return EndSessionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *EndSessionResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.EndSessionRsp)
}

func (p *EndSessionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *EndSessionResult) GetResult() interface{} {
	return p.Success
}

func sendMessageHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.SendMessageReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).SendMessage(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *SendMessageArgs:
		success, err := handler.(rag_svr.RagService).SendMessage(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SendMessageResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newSendMessageArgs() interface{} {
	return &SendMessageArgs{}
}

func newSendMessageResult() interface{} {
	return &SendMessageResult{}
}

type SendMessageArgs struct {
	Req *rag_svr.SendMessageReq
}

func (p *SendMessageArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SendMessageArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.SendMessageReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SendMessageArgs_Req_DEFAULT *rag_svr.SendMessageReq

func (p *SendMessageArgs) GetReq() *rag_svr.SendMessageReq {
	if !p.IsSetReq() {
		return SendMessageArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SendMessageArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SendMessageArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SendMessageResult struct {
	Success *rag_svr.SendMessageRsp
}

var SendMessageResult_Success_DEFAULT *rag_svr.SendMessageRsp

func (p *SendMessageResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SendMessageResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.SendMessageRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SendMessageResult) GetSuccess() *rag_svr.SendMessageRsp {
	if !p.IsSetSuccess() {
		return SendMessageResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SendMessageResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.SendMessageRsp)
}

func (p *SendMessageResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SendMessageResult) GetResult() interface{} {
	return p.Success
}

func sendMessageStreamHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	streamingArgs, ok := arg.(*streaming.Args)
	if !ok {
		return errInvalidMessageType
	}
	st := streamingArgs.Stream
	stream := &ragServiceSendMessageStreamServer{st}
	req := new(rag_svr.SendMessageReq)
	if err := st.RecvMsg(req); err != nil {
		return err
	}
	return handler.(rag_svr.RagService).SendMessageStream(req, stream)
}

type ragServiceSendMessageStreamClient struct {
	streaming.Stream
}

func (x *ragServiceSendMessageStreamClient) DoFinish(err error) {
	if finisher, ok := x.Stream.(streaming.WithDoFinish); ok {
		finisher.DoFinish(err)
	} else {
		panic(fmt.Sprintf("streaming.WithDoFinish is not implemented by %T", x.Stream))
	}
}
func (x *ragServiceSendMessageStreamClient) Recv() (*rag_svr.SendMessageRsp, error) {
	m := new(rag_svr.SendMessageRsp)
	return m, x.Stream.RecvMsg(m)
}

type ragServiceSendMessageStreamServer struct {
	streaming.Stream
}

func (x *ragServiceSendMessageStreamServer) Send(m *rag_svr.SendMessageRsp) error {
	return x.Stream.SendMsg(m)
}

func newSendMessageStreamArgs() interface{} {
	return &SendMessageStreamArgs{}
}

func newSendMessageStreamResult() interface{} {
	return &SendMessageStreamResult{}
}

type SendMessageStreamArgs struct {
	Req *rag_svr.SendMessageReq
}

func (p *SendMessageStreamArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SendMessageStreamArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.SendMessageReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SendMessageStreamArgs_Req_DEFAULT *rag_svr.SendMessageReq

func (p *SendMessageStreamArgs) GetReq() *rag_svr.SendMessageReq {
	if !p.IsSetReq() {
		return SendMessageStreamArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SendMessageStreamArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SendMessageStreamArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SendMessageStreamResult struct {
	Success *rag_svr.SendMessageRsp
}

var SendMessageStreamResult_Success_DEFAULT *rag_svr.SendMessageRsp

func (p *SendMessageStreamResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SendMessageStreamResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.SendMessageRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SendMessageStreamResult) GetSuccess() *rag_svr.SendMessageRsp {
	if !p.IsSetSuccess() {
		return SendMessageStreamResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SendMessageStreamResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.SendMessageRsp)
}

func (p *SendMessageStreamResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SendMessageStreamResult) GetResult() interface{} {
	return p.Success
}

func addDocumentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.AddDocumentReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).AddDocument(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AddDocumentArgs:
		success, err := handler.(rag_svr.RagService).AddDocument(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AddDocumentResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAddDocumentArgs() interface{} {
	return &AddDocumentArgs{}
}

func newAddDocumentResult() interface{} {
	return &AddDocumentResult{}
}

type AddDocumentArgs struct {
	Req *rag_svr.AddDocumentReq
}

func (p *AddDocumentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AddDocumentArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.AddDocumentReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AddDocumentArgs_Req_DEFAULT *rag_svr.AddDocumentReq

func (p *AddDocumentArgs) GetReq() *rag_svr.AddDocumentReq {
	if !p.IsSetReq() {
		return AddDocumentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AddDocumentArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AddDocumentArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AddDocumentResult struct {
	Success *rag_svr.AddDocumentRsp
}

var AddDocumentResult_Success_DEFAULT *rag_svr.AddDocumentRsp

func (p *AddDocumentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AddDocumentResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.AddDocumentRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AddDocumentResult) GetSuccess() *rag_svr.AddDocumentRsp {
	if !p.IsSetSuccess() {
		return AddDocumentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AddDocumentResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.AddDocumentRsp)
}

func (p *AddDocumentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AddDocumentResult) GetResult() interface{} {
	return p.Success
}

func searchDocumentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.SearchDocumentReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).SearchDocument(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *SearchDocumentArgs:
		success, err := handler.(rag_svr.RagService).SearchDocument(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SearchDocumentResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newSearchDocumentArgs() interface{} {
	return &SearchDocumentArgs{}
}

func newSearchDocumentResult() interface{} {
	return &SearchDocumentResult{}
}

type SearchDocumentArgs struct {
	Req *rag_svr.SearchDocumentReq
}

func (p *SearchDocumentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SearchDocumentArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.SearchDocumentReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SearchDocumentArgs_Req_DEFAULT *rag_svr.SearchDocumentReq

func (p *SearchDocumentArgs) GetReq() *rag_svr.SearchDocumentReq {
	if !p.IsSetReq() {
		return SearchDocumentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SearchDocumentArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SearchDocumentArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SearchDocumentResult struct {
	Success *rag_svr.SearchDocumentRsp
}

var SearchDocumentResult_Success_DEFAULT *rag_svr.SearchDocumentRsp

func (p *SearchDocumentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SearchDocumentResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.SearchDocumentRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SearchDocumentResult) GetSuccess() *rag_svr.SearchDocumentRsp {
	if !p.IsSetSuccess() {
		return SearchDocumentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SearchDocumentResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.SearchDocumentRsp)
}

func (p *SearchDocumentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SearchDocumentResult) GetResult() interface{} {
	return p.Success
}

func getSessionListHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.GetSessionListReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).GetSessionList(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetSessionListArgs:
		success, err := handler.(rag_svr.RagService).GetSessionList(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetSessionListResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetSessionListArgs() interface{} {
	return &GetSessionListArgs{}
}

func newGetSessionListResult() interface{} {
	return &GetSessionListResult{}
}

type GetSessionListArgs struct {
	Req *rag_svr.GetSessionListReq
}

func (p *GetSessionListArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetSessionListArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.GetSessionListReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetSessionListArgs_Req_DEFAULT *rag_svr.GetSessionListReq

func (p *GetSessionListArgs) GetReq() *rag_svr.GetSessionListReq {
	if !p.IsSetReq() {
		return GetSessionListArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetSessionListArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetSessionListArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetSessionListResult struct {
	Success *rag_svr.GetSessionListRsp
}

var GetSessionListResult_Success_DEFAULT *rag_svr.GetSessionListRsp

func (p *GetSessionListResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetSessionListResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.GetSessionListRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetSessionListResult) GetSuccess() *rag_svr.GetSessionListRsp {
	if !p.IsSetSuccess() {
		return GetSessionListResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetSessionListResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.GetSessionListRsp)
}

func (p *GetSessionListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetSessionListResult) GetResult() interface{} {
	return p.Success
}

func cleanInactiveSessionsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.CleanInactiveSessionsReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).CleanInactiveSessions(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CleanInactiveSessionsArgs:
		success, err := handler.(rag_svr.RagService).CleanInactiveSessions(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CleanInactiveSessionsResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCleanInactiveSessionsArgs() interface{} {
	return &CleanInactiveSessionsArgs{}
}

func newCleanInactiveSessionsResult() interface{} {
	return &CleanInactiveSessionsResult{}
}

type CleanInactiveSessionsArgs struct {
	Req *rag_svr.CleanInactiveSessionsReq
}

func (p *CleanInactiveSessionsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CleanInactiveSessionsArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.CleanInactiveSessionsReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CleanInactiveSessionsArgs_Req_DEFAULT *rag_svr.CleanInactiveSessionsReq

func (p *CleanInactiveSessionsArgs) GetReq() *rag_svr.CleanInactiveSessionsReq {
	if !p.IsSetReq() {
		return CleanInactiveSessionsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CleanInactiveSessionsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CleanInactiveSessionsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CleanInactiveSessionsResult struct {
	Success *rag_svr.CleanInactiveSessionsRsp
}

var CleanInactiveSessionsResult_Success_DEFAULT *rag_svr.CleanInactiveSessionsRsp

func (p *CleanInactiveSessionsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CleanInactiveSessionsResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.CleanInactiveSessionsRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CleanInactiveSessionsResult) GetSuccess() *rag_svr.CleanInactiveSessionsRsp {
	if !p.IsSetSuccess() {
		return CleanInactiveSessionsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CleanInactiveSessionsResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.CleanInactiveSessionsRsp)
}

func (p *CleanInactiveSessionsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CleanInactiveSessionsResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) Test(ctx context.Context, Req *rag_svr.TestReq) (r *rag_svr.TestRsp, err error) {
	var _args TestArgs
	_args.Req = Req
	var _result TestResult
	if err = p.c.Call(ctx, "Test", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Test2(ctx context.Context, Req *rag_svr.Test2Req) (r *rag_svr.Test2Rsp, err error) {
	var _args Test2Args
	_args.Req = Req
	var _result Test2Result
	if err = p.c.Call(ctx, "Test2", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateUser(ctx context.Context, Req *rag_svr.CreateUserReq) (r *rag_svr.CreateUserRsp, err error) {
	var _args CreateUserArgs
	_args.Req = Req
	var _result CreateUserResult
	if err = p.c.Call(ctx, "CreateUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateSession(ctx context.Context, Req *rag_svr.CreateSessionReq) (r *rag_svr.CreateSessionRsp, err error) {
	var _args CreateSessionArgs
	_args.Req = Req
	var _result CreateSessionResult
	if err = p.c.Call(ctx, "CreateSession", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) EndSession(ctx context.Context, Req *rag_svr.EndSessionReq) (r *rag_svr.EndSessionRsp, err error) {
	var _args EndSessionArgs
	_args.Req = Req
	var _result EndSessionResult
	if err = p.c.Call(ctx, "EndSession", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SendMessage(ctx context.Context, Req *rag_svr.SendMessageReq) (r *rag_svr.SendMessageRsp, err error) {
	var _args SendMessageArgs
	_args.Req = Req
	var _result SendMessageResult
	if err = p.c.Call(ctx, "SendMessage", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SendMessageStream(ctx context.Context, req *rag_svr.SendMessageReq) (RagService_SendMessageStreamClient, error) {
	streamClient, ok := p.c.(client.Streaming)
	if !ok {
		return nil, fmt.Errorf("client not support streaming")
	}
	res := new(streaming.Result)
	err := streamClient.Stream(ctx, "SendMessageStream", nil, res)
	if err != nil {
		return nil, err
	}
	stream := &ragServiceSendMessageStreamClient{res.Stream}

	if err := stream.Stream.SendMsg(req); err != nil {
		return nil, err
	}
	if err := stream.Stream.Close(); err != nil {
		return nil, err
	}
	return stream, nil
}

func (p *kClient) AddDocument(ctx context.Context, Req *rag_svr.AddDocumentReq) (r *rag_svr.AddDocumentRsp, err error) {
	var _args AddDocumentArgs
	_args.Req = Req
	var _result AddDocumentResult
	if err = p.c.Call(ctx, "AddDocument", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SearchDocument(ctx context.Context, Req *rag_svr.SearchDocumentReq) (r *rag_svr.SearchDocumentRsp, err error) {
	var _args SearchDocumentArgs
	_args.Req = Req
	var _result SearchDocumentResult
	if err = p.c.Call(ctx, "SearchDocument", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetSessionList(ctx context.Context, Req *rag_svr.GetSessionListReq) (r *rag_svr.GetSessionListRsp, err error) {
	var _args GetSessionListArgs
	_args.Req = Req
	var _result GetSessionListResult
	if err = p.c.Call(ctx, "GetSessionList", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CleanInactiveSessions(ctx context.Context, Req *rag_svr.CleanInactiveSessionsReq) (r *rag_svr.CleanInactiveSessionsRsp, err error) {
	var _args CleanInactiveSessionsArgs
	_args.Req = Req
	var _result CleanInactiveSessionsResult
	if err = p.c.Call(ctx, "CleanInactiveSessions", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
