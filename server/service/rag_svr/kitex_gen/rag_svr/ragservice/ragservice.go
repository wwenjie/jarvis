// Code generated by Kitex v0.13.1. DO NOT EDIT.

package ragservice

import (
	"context"
	"errors"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "github.com/cloudwego/prutal"
	rag_svr "server/service/rag_svr/kitex_gen/rag_svr"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"Test": kitex.NewMethodInfo(
		testHandler,
		newTestArgs,
		newTestResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"Test2": kitex.NewMethodInfo(
		test2Handler,
		newTest2Args,
		newTest2Result,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CreateUser": kitex.NewMethodInfo(
		createUserHandler,
		newCreateUserArgs,
		newCreateUserResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CreateSession": kitex.NewMethodInfo(
		createSessionHandler,
		newCreateSessionArgs,
		newCreateSessionResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetSession": kitex.NewMethodInfo(
		getSessionHandler,
		newGetSessionArgs,
		newGetSessionResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"EndSession": kitex.NewMethodInfo(
		endSessionHandler,
		newEndSessionArgs,
		newEndSessionResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetSessionList": kitex.NewMethodInfo(
		getSessionListHandler,
		newGetSessionListArgs,
		newGetSessionListResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CleanInactiveSessions": kitex.NewMethodInfo(
		cleanInactiveSessionsHandler,
		newCleanInactiveSessionsArgs,
		newCleanInactiveSessionsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AddDocument": kitex.NewMethodInfo(
		addDocumentHandler,
		newAddDocumentArgs,
		newAddDocumentResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DeleteDocument": kitex.NewMethodInfo(
		deleteDocumentHandler,
		newDeleteDocumentArgs,
		newDeleteDocumentResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"SearchDocument": kitex.NewMethodInfo(
		searchDocumentHandler,
		newSearchDocumentArgs,
		newSearchDocumentResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ListDocument": kitex.NewMethodInfo(
		listDocumentHandler,
		newListDocumentArgs,
		newListDocumentResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AddMemory": kitex.NewMethodInfo(
		addMemoryHandler,
		newAddMemoryArgs,
		newAddMemoryResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetMemory": kitex.NewMethodInfo(
		getMemoryHandler,
		newGetMemoryArgs,
		newGetMemoryResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"SearchMemories": kitex.NewMethodInfo(
		searchMemoriesHandler,
		newSearchMemoriesArgs,
		newSearchMemoriesResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DeleteMemory": kitex.NewMethodInfo(
		deleteMemoryHandler,
		newDeleteMemoryArgs,
		newDeleteMemoryResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AddChatRecord": kitex.NewMethodInfo(
		addChatRecordHandler,
		newAddChatRecordArgs,
		newAddChatRecordResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetChatRecords": kitex.NewMethodInfo(
		getChatRecordsHandler,
		newGetChatRecordsArgs,
		newGetChatRecordsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	ragServiceServiceInfo                = NewServiceInfo()
	ragServiceServiceInfoForClient       = NewServiceInfoForClient()
	ragServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return ragServiceServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return ragServiceServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return ragServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "RagService"
	handlerType := (*rag_svr.RagService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "rag_svr",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.13.1",
		Extra:           extra,
	}
	return svcInfo
}

func testHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.TestReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).Test(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *TestArgs:
		success, err := handler.(rag_svr.RagService).Test(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*TestResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newTestArgs() interface{} {
	return &TestArgs{}
}

func newTestResult() interface{} {
	return &TestResult{}
}

type TestArgs struct {
	Req *rag_svr.TestReq
}

func (p *TestArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *TestArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.TestReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var TestArgs_Req_DEFAULT *rag_svr.TestReq

func (p *TestArgs) GetReq() *rag_svr.TestReq {
	if !p.IsSetReq() {
		return TestArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *TestArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *TestArgs) GetFirstArgument() interface{} {
	return p.Req
}

type TestResult struct {
	Success *rag_svr.TestRsp
}

var TestResult_Success_DEFAULT *rag_svr.TestRsp

func (p *TestResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *TestResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.TestRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *TestResult) GetSuccess() *rag_svr.TestRsp {
	if !p.IsSetSuccess() {
		return TestResult_Success_DEFAULT
	}
	return p.Success
}

func (p *TestResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.TestRsp)
}

func (p *TestResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestResult) GetResult() interface{} {
	return p.Success
}

func test2Handler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.Test2Req)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).Test2(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *Test2Args:
		success, err := handler.(rag_svr.RagService).Test2(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*Test2Result)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newTest2Args() interface{} {
	return &Test2Args{}
}

func newTest2Result() interface{} {
	return &Test2Result{}
}

type Test2Args struct {
	Req *rag_svr.Test2Req
}

func (p *Test2Args) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *Test2Args) Unmarshal(in []byte) error {
	msg := new(rag_svr.Test2Req)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var Test2Args_Req_DEFAULT *rag_svr.Test2Req

func (p *Test2Args) GetReq() *rag_svr.Test2Req {
	if !p.IsSetReq() {
		return Test2Args_Req_DEFAULT
	}
	return p.Req
}

func (p *Test2Args) IsSetReq() bool {
	return p.Req != nil
}

func (p *Test2Args) GetFirstArgument() interface{} {
	return p.Req
}

type Test2Result struct {
	Success *rag_svr.Test2Rsp
}

var Test2Result_Success_DEFAULT *rag_svr.Test2Rsp

func (p *Test2Result) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *Test2Result) Unmarshal(in []byte) error {
	msg := new(rag_svr.Test2Rsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *Test2Result) GetSuccess() *rag_svr.Test2Rsp {
	if !p.IsSetSuccess() {
		return Test2Result_Success_DEFAULT
	}
	return p.Success
}

func (p *Test2Result) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.Test2Rsp)
}

func (p *Test2Result) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *Test2Result) GetResult() interface{} {
	return p.Success
}

func createUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.CreateUserReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).CreateUser(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CreateUserArgs:
		success, err := handler.(rag_svr.RagService).CreateUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateUserResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCreateUserArgs() interface{} {
	return &CreateUserArgs{}
}

func newCreateUserResult() interface{} {
	return &CreateUserResult{}
}

type CreateUserArgs struct {
	Req *rag_svr.CreateUserReq
}

func (p *CreateUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateUserArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.CreateUserReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateUserArgs_Req_DEFAULT *rag_svr.CreateUserReq

func (p *CreateUserArgs) GetReq() *rag_svr.CreateUserReq {
	if !p.IsSetReq() {
		return CreateUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateUserResult struct {
	Success *rag_svr.CreateUserRsp
}

var CreateUserResult_Success_DEFAULT *rag_svr.CreateUserRsp

func (p *CreateUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateUserResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.CreateUserRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateUserResult) GetSuccess() *rag_svr.CreateUserRsp {
	if !p.IsSetSuccess() {
		return CreateUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.CreateUserRsp)
}

func (p *CreateUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateUserResult) GetResult() interface{} {
	return p.Success
}

func createSessionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.CreateSessionReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).CreateSession(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CreateSessionArgs:
		success, err := handler.(rag_svr.RagService).CreateSession(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateSessionResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCreateSessionArgs() interface{} {
	return &CreateSessionArgs{}
}

func newCreateSessionResult() interface{} {
	return &CreateSessionResult{}
}

type CreateSessionArgs struct {
	Req *rag_svr.CreateSessionReq
}

func (p *CreateSessionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateSessionArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.CreateSessionReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateSessionArgs_Req_DEFAULT *rag_svr.CreateSessionReq

func (p *CreateSessionArgs) GetReq() *rag_svr.CreateSessionReq {
	if !p.IsSetReq() {
		return CreateSessionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateSessionArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateSessionArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateSessionResult struct {
	Success *rag_svr.CreateSessionRsp
}

var CreateSessionResult_Success_DEFAULT *rag_svr.CreateSessionRsp

func (p *CreateSessionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateSessionResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.CreateSessionRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateSessionResult) GetSuccess() *rag_svr.CreateSessionRsp {
	if !p.IsSetSuccess() {
		return CreateSessionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateSessionResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.CreateSessionRsp)
}

func (p *CreateSessionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateSessionResult) GetResult() interface{} {
	return p.Success
}

func getSessionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.GetSessionReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).GetSession(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetSessionArgs:
		success, err := handler.(rag_svr.RagService).GetSession(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetSessionResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetSessionArgs() interface{} {
	return &GetSessionArgs{}
}

func newGetSessionResult() interface{} {
	return &GetSessionResult{}
}

type GetSessionArgs struct {
	Req *rag_svr.GetSessionReq
}

func (p *GetSessionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetSessionArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.GetSessionReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetSessionArgs_Req_DEFAULT *rag_svr.GetSessionReq

func (p *GetSessionArgs) GetReq() *rag_svr.GetSessionReq {
	if !p.IsSetReq() {
		return GetSessionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetSessionArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetSessionArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetSessionResult struct {
	Success *rag_svr.GetSessionRsp
}

var GetSessionResult_Success_DEFAULT *rag_svr.GetSessionRsp

func (p *GetSessionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetSessionResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.GetSessionRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetSessionResult) GetSuccess() *rag_svr.GetSessionRsp {
	if !p.IsSetSuccess() {
		return GetSessionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetSessionResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.GetSessionRsp)
}

func (p *GetSessionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetSessionResult) GetResult() interface{} {
	return p.Success
}

func endSessionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.EndSessionReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).EndSession(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *EndSessionArgs:
		success, err := handler.(rag_svr.RagService).EndSession(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*EndSessionResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newEndSessionArgs() interface{} {
	return &EndSessionArgs{}
}

func newEndSessionResult() interface{} {
	return &EndSessionResult{}
}

type EndSessionArgs struct {
	Req *rag_svr.EndSessionReq
}

func (p *EndSessionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *EndSessionArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.EndSessionReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var EndSessionArgs_Req_DEFAULT *rag_svr.EndSessionReq

func (p *EndSessionArgs) GetReq() *rag_svr.EndSessionReq {
	if !p.IsSetReq() {
		return EndSessionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *EndSessionArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *EndSessionArgs) GetFirstArgument() interface{} {
	return p.Req
}

type EndSessionResult struct {
	Success *rag_svr.EndSessionRsp
}

var EndSessionResult_Success_DEFAULT *rag_svr.EndSessionRsp

func (p *EndSessionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *EndSessionResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.EndSessionRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *EndSessionResult) GetSuccess() *rag_svr.EndSessionRsp {
	if !p.IsSetSuccess() {
		return EndSessionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *EndSessionResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.EndSessionRsp)
}

func (p *EndSessionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *EndSessionResult) GetResult() interface{} {
	return p.Success
}

func getSessionListHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.GetSessionListReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).GetSessionList(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetSessionListArgs:
		success, err := handler.(rag_svr.RagService).GetSessionList(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetSessionListResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetSessionListArgs() interface{} {
	return &GetSessionListArgs{}
}

func newGetSessionListResult() interface{} {
	return &GetSessionListResult{}
}

type GetSessionListArgs struct {
	Req *rag_svr.GetSessionListReq
}

func (p *GetSessionListArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetSessionListArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.GetSessionListReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetSessionListArgs_Req_DEFAULT *rag_svr.GetSessionListReq

func (p *GetSessionListArgs) GetReq() *rag_svr.GetSessionListReq {
	if !p.IsSetReq() {
		return GetSessionListArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetSessionListArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetSessionListArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetSessionListResult struct {
	Success *rag_svr.GetSessionListRsp
}

var GetSessionListResult_Success_DEFAULT *rag_svr.GetSessionListRsp

func (p *GetSessionListResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetSessionListResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.GetSessionListRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetSessionListResult) GetSuccess() *rag_svr.GetSessionListRsp {
	if !p.IsSetSuccess() {
		return GetSessionListResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetSessionListResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.GetSessionListRsp)
}

func (p *GetSessionListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetSessionListResult) GetResult() interface{} {
	return p.Success
}

func cleanInactiveSessionsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.CleanInactiveSessionsReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).CleanInactiveSessions(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CleanInactiveSessionsArgs:
		success, err := handler.(rag_svr.RagService).CleanInactiveSessions(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CleanInactiveSessionsResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCleanInactiveSessionsArgs() interface{} {
	return &CleanInactiveSessionsArgs{}
}

func newCleanInactiveSessionsResult() interface{} {
	return &CleanInactiveSessionsResult{}
}

type CleanInactiveSessionsArgs struct {
	Req *rag_svr.CleanInactiveSessionsReq
}

func (p *CleanInactiveSessionsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CleanInactiveSessionsArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.CleanInactiveSessionsReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CleanInactiveSessionsArgs_Req_DEFAULT *rag_svr.CleanInactiveSessionsReq

func (p *CleanInactiveSessionsArgs) GetReq() *rag_svr.CleanInactiveSessionsReq {
	if !p.IsSetReq() {
		return CleanInactiveSessionsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CleanInactiveSessionsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CleanInactiveSessionsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CleanInactiveSessionsResult struct {
	Success *rag_svr.CleanInactiveSessionsRsp
}

var CleanInactiveSessionsResult_Success_DEFAULT *rag_svr.CleanInactiveSessionsRsp

func (p *CleanInactiveSessionsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CleanInactiveSessionsResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.CleanInactiveSessionsRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CleanInactiveSessionsResult) GetSuccess() *rag_svr.CleanInactiveSessionsRsp {
	if !p.IsSetSuccess() {
		return CleanInactiveSessionsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CleanInactiveSessionsResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.CleanInactiveSessionsRsp)
}

func (p *CleanInactiveSessionsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CleanInactiveSessionsResult) GetResult() interface{} {
	return p.Success
}

func addDocumentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.AddDocumentReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).AddDocument(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AddDocumentArgs:
		success, err := handler.(rag_svr.RagService).AddDocument(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AddDocumentResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAddDocumentArgs() interface{} {
	return &AddDocumentArgs{}
}

func newAddDocumentResult() interface{} {
	return &AddDocumentResult{}
}

type AddDocumentArgs struct {
	Req *rag_svr.AddDocumentReq
}

func (p *AddDocumentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AddDocumentArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.AddDocumentReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AddDocumentArgs_Req_DEFAULT *rag_svr.AddDocumentReq

func (p *AddDocumentArgs) GetReq() *rag_svr.AddDocumentReq {
	if !p.IsSetReq() {
		return AddDocumentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AddDocumentArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AddDocumentArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AddDocumentResult struct {
	Success *rag_svr.AddDocumentRsp
}

var AddDocumentResult_Success_DEFAULT *rag_svr.AddDocumentRsp

func (p *AddDocumentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AddDocumentResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.AddDocumentRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AddDocumentResult) GetSuccess() *rag_svr.AddDocumentRsp {
	if !p.IsSetSuccess() {
		return AddDocumentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AddDocumentResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.AddDocumentRsp)
}

func (p *AddDocumentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AddDocumentResult) GetResult() interface{} {
	return p.Success
}

func deleteDocumentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.DeleteDocumentReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).DeleteDocument(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DeleteDocumentArgs:
		success, err := handler.(rag_svr.RagService).DeleteDocument(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteDocumentResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDeleteDocumentArgs() interface{} {
	return &DeleteDocumentArgs{}
}

func newDeleteDocumentResult() interface{} {
	return &DeleteDocumentResult{}
}

type DeleteDocumentArgs struct {
	Req *rag_svr.DeleteDocumentReq
}

func (p *DeleteDocumentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteDocumentArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.DeleteDocumentReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteDocumentArgs_Req_DEFAULT *rag_svr.DeleteDocumentReq

func (p *DeleteDocumentArgs) GetReq() *rag_svr.DeleteDocumentReq {
	if !p.IsSetReq() {
		return DeleteDocumentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteDocumentArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteDocumentArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteDocumentResult struct {
	Success *rag_svr.DeleteDocumentRsp
}

var DeleteDocumentResult_Success_DEFAULT *rag_svr.DeleteDocumentRsp

func (p *DeleteDocumentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteDocumentResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.DeleteDocumentRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteDocumentResult) GetSuccess() *rag_svr.DeleteDocumentRsp {
	if !p.IsSetSuccess() {
		return DeleteDocumentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteDocumentResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.DeleteDocumentRsp)
}

func (p *DeleteDocumentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteDocumentResult) GetResult() interface{} {
	return p.Success
}

func searchDocumentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.SearchDocumentReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).SearchDocument(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *SearchDocumentArgs:
		success, err := handler.(rag_svr.RagService).SearchDocument(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SearchDocumentResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newSearchDocumentArgs() interface{} {
	return &SearchDocumentArgs{}
}

func newSearchDocumentResult() interface{} {
	return &SearchDocumentResult{}
}

type SearchDocumentArgs struct {
	Req *rag_svr.SearchDocumentReq
}

func (p *SearchDocumentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SearchDocumentArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.SearchDocumentReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SearchDocumentArgs_Req_DEFAULT *rag_svr.SearchDocumentReq

func (p *SearchDocumentArgs) GetReq() *rag_svr.SearchDocumentReq {
	if !p.IsSetReq() {
		return SearchDocumentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SearchDocumentArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SearchDocumentArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SearchDocumentResult struct {
	Success *rag_svr.SearchDocumentRsp
}

var SearchDocumentResult_Success_DEFAULT *rag_svr.SearchDocumentRsp

func (p *SearchDocumentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SearchDocumentResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.SearchDocumentRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SearchDocumentResult) GetSuccess() *rag_svr.SearchDocumentRsp {
	if !p.IsSetSuccess() {
		return SearchDocumentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SearchDocumentResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.SearchDocumentRsp)
}

func (p *SearchDocumentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SearchDocumentResult) GetResult() interface{} {
	return p.Success
}

func listDocumentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.ListDocumentReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).ListDocument(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ListDocumentArgs:
		success, err := handler.(rag_svr.RagService).ListDocument(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListDocumentResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newListDocumentArgs() interface{} {
	return &ListDocumentArgs{}
}

func newListDocumentResult() interface{} {
	return &ListDocumentResult{}
}

type ListDocumentArgs struct {
	Req *rag_svr.ListDocumentReq
}

func (p *ListDocumentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ListDocumentArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.ListDocumentReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListDocumentArgs_Req_DEFAULT *rag_svr.ListDocumentReq

func (p *ListDocumentArgs) GetReq() *rag_svr.ListDocumentReq {
	if !p.IsSetReq() {
		return ListDocumentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListDocumentArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ListDocumentArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ListDocumentResult struct {
	Success *rag_svr.ListDocumentRsp
}

var ListDocumentResult_Success_DEFAULT *rag_svr.ListDocumentRsp

func (p *ListDocumentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ListDocumentResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.ListDocumentRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListDocumentResult) GetSuccess() *rag_svr.ListDocumentRsp {
	if !p.IsSetSuccess() {
		return ListDocumentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListDocumentResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.ListDocumentRsp)
}

func (p *ListDocumentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListDocumentResult) GetResult() interface{} {
	return p.Success
}

func addMemoryHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.AddMemoryReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).AddMemory(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AddMemoryArgs:
		success, err := handler.(rag_svr.RagService).AddMemory(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AddMemoryResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAddMemoryArgs() interface{} {
	return &AddMemoryArgs{}
}

func newAddMemoryResult() interface{} {
	return &AddMemoryResult{}
}

type AddMemoryArgs struct {
	Req *rag_svr.AddMemoryReq
}

func (p *AddMemoryArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AddMemoryArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.AddMemoryReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AddMemoryArgs_Req_DEFAULT *rag_svr.AddMemoryReq

func (p *AddMemoryArgs) GetReq() *rag_svr.AddMemoryReq {
	if !p.IsSetReq() {
		return AddMemoryArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AddMemoryArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AddMemoryArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AddMemoryResult struct {
	Success *rag_svr.AddMemoryRsp
}

var AddMemoryResult_Success_DEFAULT *rag_svr.AddMemoryRsp

func (p *AddMemoryResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AddMemoryResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.AddMemoryRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AddMemoryResult) GetSuccess() *rag_svr.AddMemoryRsp {
	if !p.IsSetSuccess() {
		return AddMemoryResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AddMemoryResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.AddMemoryRsp)
}

func (p *AddMemoryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AddMemoryResult) GetResult() interface{} {
	return p.Success
}

func getMemoryHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.GetMemoryReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).GetMemory(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetMemoryArgs:
		success, err := handler.(rag_svr.RagService).GetMemory(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetMemoryResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetMemoryArgs() interface{} {
	return &GetMemoryArgs{}
}

func newGetMemoryResult() interface{} {
	return &GetMemoryResult{}
}

type GetMemoryArgs struct {
	Req *rag_svr.GetMemoryReq
}

func (p *GetMemoryArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetMemoryArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.GetMemoryReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetMemoryArgs_Req_DEFAULT *rag_svr.GetMemoryReq

func (p *GetMemoryArgs) GetReq() *rag_svr.GetMemoryReq {
	if !p.IsSetReq() {
		return GetMemoryArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetMemoryArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetMemoryArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetMemoryResult struct {
	Success *rag_svr.GetMemoryRsp
}

var GetMemoryResult_Success_DEFAULT *rag_svr.GetMemoryRsp

func (p *GetMemoryResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetMemoryResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.GetMemoryRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetMemoryResult) GetSuccess() *rag_svr.GetMemoryRsp {
	if !p.IsSetSuccess() {
		return GetMemoryResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetMemoryResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.GetMemoryRsp)
}

func (p *GetMemoryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetMemoryResult) GetResult() interface{} {
	return p.Success
}

func searchMemoriesHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.SearchMemoriesReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).SearchMemories(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *SearchMemoriesArgs:
		success, err := handler.(rag_svr.RagService).SearchMemories(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SearchMemoriesResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newSearchMemoriesArgs() interface{} {
	return &SearchMemoriesArgs{}
}

func newSearchMemoriesResult() interface{} {
	return &SearchMemoriesResult{}
}

type SearchMemoriesArgs struct {
	Req *rag_svr.SearchMemoriesReq
}

func (p *SearchMemoriesArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SearchMemoriesArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.SearchMemoriesReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SearchMemoriesArgs_Req_DEFAULT *rag_svr.SearchMemoriesReq

func (p *SearchMemoriesArgs) GetReq() *rag_svr.SearchMemoriesReq {
	if !p.IsSetReq() {
		return SearchMemoriesArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SearchMemoriesArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SearchMemoriesArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SearchMemoriesResult struct {
	Success *rag_svr.SearchMemoriesRsp
}

var SearchMemoriesResult_Success_DEFAULT *rag_svr.SearchMemoriesRsp

func (p *SearchMemoriesResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SearchMemoriesResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.SearchMemoriesRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SearchMemoriesResult) GetSuccess() *rag_svr.SearchMemoriesRsp {
	if !p.IsSetSuccess() {
		return SearchMemoriesResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SearchMemoriesResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.SearchMemoriesRsp)
}

func (p *SearchMemoriesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SearchMemoriesResult) GetResult() interface{} {
	return p.Success
}

func deleteMemoryHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.DeleteMemoryReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).DeleteMemory(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DeleteMemoryArgs:
		success, err := handler.(rag_svr.RagService).DeleteMemory(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteMemoryResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDeleteMemoryArgs() interface{} {
	return &DeleteMemoryArgs{}
}

func newDeleteMemoryResult() interface{} {
	return &DeleteMemoryResult{}
}

type DeleteMemoryArgs struct {
	Req *rag_svr.DeleteMemoryReq
}

func (p *DeleteMemoryArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteMemoryArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.DeleteMemoryReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteMemoryArgs_Req_DEFAULT *rag_svr.DeleteMemoryReq

func (p *DeleteMemoryArgs) GetReq() *rag_svr.DeleteMemoryReq {
	if !p.IsSetReq() {
		return DeleteMemoryArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteMemoryArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteMemoryArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteMemoryResult struct {
	Success *rag_svr.DeleteMemoryRsp
}

var DeleteMemoryResult_Success_DEFAULT *rag_svr.DeleteMemoryRsp

func (p *DeleteMemoryResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteMemoryResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.DeleteMemoryRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteMemoryResult) GetSuccess() *rag_svr.DeleteMemoryRsp {
	if !p.IsSetSuccess() {
		return DeleteMemoryResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteMemoryResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.DeleteMemoryRsp)
}

func (p *DeleteMemoryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteMemoryResult) GetResult() interface{} {
	return p.Success
}

func addChatRecordHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.AddChatRecordReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).AddChatRecord(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AddChatRecordArgs:
		success, err := handler.(rag_svr.RagService).AddChatRecord(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AddChatRecordResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAddChatRecordArgs() interface{} {
	return &AddChatRecordArgs{}
}

func newAddChatRecordResult() interface{} {
	return &AddChatRecordResult{}
}

type AddChatRecordArgs struct {
	Req *rag_svr.AddChatRecordReq
}

func (p *AddChatRecordArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AddChatRecordArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.AddChatRecordReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AddChatRecordArgs_Req_DEFAULT *rag_svr.AddChatRecordReq

func (p *AddChatRecordArgs) GetReq() *rag_svr.AddChatRecordReq {
	if !p.IsSetReq() {
		return AddChatRecordArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AddChatRecordArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AddChatRecordArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AddChatRecordResult struct {
	Success *rag_svr.AddChatRecordRsp
}

var AddChatRecordResult_Success_DEFAULT *rag_svr.AddChatRecordRsp

func (p *AddChatRecordResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AddChatRecordResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.AddChatRecordRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AddChatRecordResult) GetSuccess() *rag_svr.AddChatRecordRsp {
	if !p.IsSetSuccess() {
		return AddChatRecordResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AddChatRecordResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.AddChatRecordRsp)
}

func (p *AddChatRecordResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AddChatRecordResult) GetResult() interface{} {
	return p.Success
}

func getChatRecordsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(rag_svr.GetChatRecordsReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(rag_svr.RagService).GetChatRecords(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetChatRecordsArgs:
		success, err := handler.(rag_svr.RagService).GetChatRecords(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetChatRecordsResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetChatRecordsArgs() interface{} {
	return &GetChatRecordsArgs{}
}

func newGetChatRecordsResult() interface{} {
	return &GetChatRecordsResult{}
}

type GetChatRecordsArgs struct {
	Req *rag_svr.GetChatRecordsReq
}

func (p *GetChatRecordsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetChatRecordsArgs) Unmarshal(in []byte) error {
	msg := new(rag_svr.GetChatRecordsReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetChatRecordsArgs_Req_DEFAULT *rag_svr.GetChatRecordsReq

func (p *GetChatRecordsArgs) GetReq() *rag_svr.GetChatRecordsReq {
	if !p.IsSetReq() {
		return GetChatRecordsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetChatRecordsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetChatRecordsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetChatRecordsResult struct {
	Success *rag_svr.GetChatRecordsRsp
}

var GetChatRecordsResult_Success_DEFAULT *rag_svr.GetChatRecordsRsp

func (p *GetChatRecordsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetChatRecordsResult) Unmarshal(in []byte) error {
	msg := new(rag_svr.GetChatRecordsRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetChatRecordsResult) GetSuccess() *rag_svr.GetChatRecordsRsp {
	if !p.IsSetSuccess() {
		return GetChatRecordsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetChatRecordsResult) SetSuccess(x interface{}) {
	p.Success = x.(*rag_svr.GetChatRecordsRsp)
}

func (p *GetChatRecordsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetChatRecordsResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) Test(ctx context.Context, Req *rag_svr.TestReq) (r *rag_svr.TestRsp, err error) {
	var _args TestArgs
	_args.Req = Req
	var _result TestResult
	if err = p.c.Call(ctx, "Test", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Test2(ctx context.Context, Req *rag_svr.Test2Req) (r *rag_svr.Test2Rsp, err error) {
	var _args Test2Args
	_args.Req = Req
	var _result Test2Result
	if err = p.c.Call(ctx, "Test2", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateUser(ctx context.Context, Req *rag_svr.CreateUserReq) (r *rag_svr.CreateUserRsp, err error) {
	var _args CreateUserArgs
	_args.Req = Req
	var _result CreateUserResult
	if err = p.c.Call(ctx, "CreateUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateSession(ctx context.Context, Req *rag_svr.CreateSessionReq) (r *rag_svr.CreateSessionRsp, err error) {
	var _args CreateSessionArgs
	_args.Req = Req
	var _result CreateSessionResult
	if err = p.c.Call(ctx, "CreateSession", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetSession(ctx context.Context, Req *rag_svr.GetSessionReq) (r *rag_svr.GetSessionRsp, err error) {
	var _args GetSessionArgs
	_args.Req = Req
	var _result GetSessionResult
	if err = p.c.Call(ctx, "GetSession", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) EndSession(ctx context.Context, Req *rag_svr.EndSessionReq) (r *rag_svr.EndSessionRsp, err error) {
	var _args EndSessionArgs
	_args.Req = Req
	var _result EndSessionResult
	if err = p.c.Call(ctx, "EndSession", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetSessionList(ctx context.Context, Req *rag_svr.GetSessionListReq) (r *rag_svr.GetSessionListRsp, err error) {
	var _args GetSessionListArgs
	_args.Req = Req
	var _result GetSessionListResult
	if err = p.c.Call(ctx, "GetSessionList", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CleanInactiveSessions(ctx context.Context, Req *rag_svr.CleanInactiveSessionsReq) (r *rag_svr.CleanInactiveSessionsRsp, err error) {
	var _args CleanInactiveSessionsArgs
	_args.Req = Req
	var _result CleanInactiveSessionsResult
	if err = p.c.Call(ctx, "CleanInactiveSessions", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AddDocument(ctx context.Context, Req *rag_svr.AddDocumentReq) (r *rag_svr.AddDocumentRsp, err error) {
	var _args AddDocumentArgs
	_args.Req = Req
	var _result AddDocumentResult
	if err = p.c.Call(ctx, "AddDocument", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteDocument(ctx context.Context, Req *rag_svr.DeleteDocumentReq) (r *rag_svr.DeleteDocumentRsp, err error) {
	var _args DeleteDocumentArgs
	_args.Req = Req
	var _result DeleteDocumentResult
	if err = p.c.Call(ctx, "DeleteDocument", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SearchDocument(ctx context.Context, Req *rag_svr.SearchDocumentReq) (r *rag_svr.SearchDocumentRsp, err error) {
	var _args SearchDocumentArgs
	_args.Req = Req
	var _result SearchDocumentResult
	if err = p.c.Call(ctx, "SearchDocument", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListDocument(ctx context.Context, Req *rag_svr.ListDocumentReq) (r *rag_svr.ListDocumentRsp, err error) {
	var _args ListDocumentArgs
	_args.Req = Req
	var _result ListDocumentResult
	if err = p.c.Call(ctx, "ListDocument", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AddMemory(ctx context.Context, Req *rag_svr.AddMemoryReq) (r *rag_svr.AddMemoryRsp, err error) {
	var _args AddMemoryArgs
	_args.Req = Req
	var _result AddMemoryResult
	if err = p.c.Call(ctx, "AddMemory", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetMemory(ctx context.Context, Req *rag_svr.GetMemoryReq) (r *rag_svr.GetMemoryRsp, err error) {
	var _args GetMemoryArgs
	_args.Req = Req
	var _result GetMemoryResult
	if err = p.c.Call(ctx, "GetMemory", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SearchMemories(ctx context.Context, Req *rag_svr.SearchMemoriesReq) (r *rag_svr.SearchMemoriesRsp, err error) {
	var _args SearchMemoriesArgs
	_args.Req = Req
	var _result SearchMemoriesResult
	if err = p.c.Call(ctx, "SearchMemories", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteMemory(ctx context.Context, Req *rag_svr.DeleteMemoryReq) (r *rag_svr.DeleteMemoryRsp, err error) {
	var _args DeleteMemoryArgs
	_args.Req = Req
	var _result DeleteMemoryResult
	if err = p.c.Call(ctx, "DeleteMemory", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AddChatRecord(ctx context.Context, Req *rag_svr.AddChatRecordReq) (r *rag_svr.AddChatRecordRsp, err error) {
	var _args AddChatRecordArgs
	_args.Req = Req
	var _result AddChatRecordResult
	if err = p.c.Call(ctx, "AddChatRecord", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetChatRecords(ctx context.Context, Req *rag_svr.GetChatRecordsReq) (r *rag_svr.GetChatRecordsRsp, err error) {
	var _args GetChatRecordsArgs
	_args.Req = Req
	var _result GetChatRecordsResult
	if err = p.c.Call(ctx, "GetChatRecords", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
